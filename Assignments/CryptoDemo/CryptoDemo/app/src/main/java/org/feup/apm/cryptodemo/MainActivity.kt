package org.feup.apm.cryptodemo

import android.os.Bundle
import android.security.KeyPairGeneratorSpec
import android.util.Base64
import android.view.Menu
import android.view.MenuItem
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import java.math.BigInteger
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.SecureRandom
import java.security.Signature
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.util.*
import javax.crypto.Cipher
import javax.security.auth.x500.X500Principal

/*
 *    Constant strings
 */

object InStrings {
  const val haveKeys = "generated"
  const val notHaveKeys = "not generated"
  const val beginCert = "-----BEGIN CERTIFICATE-----\n"
  const val endCert = "-----END CERTIFICATE-----\n"
  const val showKeysFormat = "Modulus(%d):\n%s\nExponent: %s\nPrivate Exponent(%d):\n%s"
  const val contentFormat = "Content(%d):\n%s"
  const val encFormat = "Encrypted(%d):\n%s"
  const val decFormat = "Decrypted(%s):\n%s"
  const val signFormat = "Signature(%s):\n%s"
  const val certFormat = "(DER:%d):\n%s\n\nPEM(b64:%d):\n%s\n%s"
}

/*
 *     General Utility Functions
 */

fun byteArrayToHex(ba: ByteArray): String {
  val sb = StringBuilder(ba.size * 2)
  for (b in ba) sb.append(String.format("%02x", b))
  return sb.toString()
}

data class PubKey(var modulus: ByteArray, var exponent: ByteArray)

class MainActivity : AppCompatActivity() {
  val tvGenerated by lazy { findViewById<TextView>(R.id.tv_gen) }
  val tvExc by lazy { findViewById<TextView>(R.id.tv_exc) }
  val tvMsg by lazy { findViewById<TextView>(R.id.tv_msg) }
  val tvResult by lazy { findViewById<TextView>(R.id.tv_op_result) }
  val tvResult2 by lazy { findViewById<TextView>(R.id.tv_op_result2) }
  var generated = false
  var content = ByteArray(0)
  var result = ByteArray(0)
  var clear = ByteArray(0)

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    generated = keysPresent()
    tvGenerated.text = if (generated) InStrings.haveKeys else InStrings.notHaveKeys
    findViewById<Button>(R.id.bt_generate).apply {
      isEnabled = !generated
      setOnClickListener { btGenOnClick(it as Button) }
    }
  }

  private fun keysPresent(): Boolean {
    val entry = KeyStore.getInstance(Constants.ANDROID_KEYSTORE).run {
      load(null)
      getEntry(Constants.keyname, null)
    }
    return (entry !== null)
  }

  /*
   *    Button listener
   */

  private fun btGenOnClick(bt: Button) {
    generated = generateAndStoreKeys()
    if (generated) {
      tvGenerated.text = InStrings.haveKeys
      bt.isEnabled = false
    }
  }

  /*
   *     Options menu callbacks
   */

  override fun onCreateOptionsMenu(menu: Menu): Boolean {
    menuInflater.inflate(R.menu.menu_main, menu)
    return true
  }

  override fun onPrepareOptionsMenu(menu: Menu): Boolean {
    super.onPrepareOptionsMenu(menu)
    for (k in 0 until menu.size())
      menu.getItem(k).isEnabled = generated
    return true
  }

  override fun onOptionsItemSelected(item: MenuItem): Boolean {
    when (item.getItemId()) {
      R.id.mn_it_show -> showKeys()
      R.id.mn_it_gen_content -> genRandomContent()
      R.id.mn_it_enc -> encryptContent()
      R.id.mn_it_dec -> decryptResult()
      R.id.mn_it_sign -> signContent()
      R.id.mn_it_verify -> verifySignature()
      R.id.mn_it_cert -> showCertificate()
      R.id.mn_it_clear -> clearScreen()
      else -> return false
    }
    return true
  }

  /*
   *    Button generate functionality
   */

  private fun generateAndStoreKeys(): Boolean {
    try {
      if (!generated) {
        val start = GregorianCalendar()
        val end = GregorianCalendar().apply { add(Calendar.YEAR, 10) }
        val kgen = KeyPairGenerator.getInstance(Constants.KEY_ALGO, Constants.ANDROID_KEYSTORE)
        val spec = KeyPairGeneratorSpec.Builder(this)
          .setKeySize(Constants.KEY_SIZE)
          .setAlias(Constants.keyname)
          .setSubject(X500Principal("CN=" + Constants.keyname))
          .setSerialNumber(BigInteger.valueOf(Constants.serialNr))
          .setStartDate(start.time)
          .setEndDate(end.time)
          .build()
        kgen.initialize(spec)
        kgen.generateKeyPair()
      }
    }
    catch (ex: Exception) {
      tvExc.text = ex.message
      return false
    }
    return true
  }

  /*
   *      Menu - show keys functionality
   */

  fun getPubKey(): PubKey {
    val pkey = PubKey(ByteArray(0), ByteArray(0))
    try {
      val entry = KeyStore.getInstance(Constants.ANDROID_KEYSTORE).run {
        load(null)
        getEntry(Constants.keyname, null)
      }
      val pub = (entry as KeyStore.PrivateKeyEntry).certificate.publicKey
      pkey.modulus = (pub as RSAPublicKey).getModulus().toByteArray()
      pkey.exponent = (pub as RSAPublicKey).getPublicExponent().toByteArray()
    }
    catch (ex: Exception) {
      tvExc.text = ex.message
    }
    return pkey
  }

  fun getPrivExp(): ByteArray {
    var exp = ByteArray(0)
    try {
      val entry = KeyStore.getInstance(Constants.ANDROID_KEYSTORE).run {
        load(null)
        getEntry(Constants.keyname, null)
      }
      val priv = (entry as KeyStore.PrivateKeyEntry).privateKey
      exp = (priv as RSAPrivateKey).getPrivateExponent().toByteArray()
    }
    catch (ex: Exception) {
      tvExc.text = ex.message
    }
    return exp
  }

  private fun showKeys() {
    val pkey = getPubKey()
    val privExp = getPrivExp()
    tvMsg.text = String.format(InStrings.showKeysFormat, pkey.modulus.size, byteArrayToHex(pkey.modulus),
                               byteArrayToHex(pkey.exponent), privExp.size, byteArrayToHex(privExp))
  }

  /*
   *     Menu - generate content functionality
   */

  fun genRandomContent() {
    content = ByteArray(20)
    SecureRandom().nextBytes(content)
    tvMsg.text = String.format(InStrings.contentFormat , content.size, byteArrayToHex(content))
  }

  /*
   *      Menu - encrypt and decrypt
   */

  fun encryptContent() {
    if (content.size == 0) return
    tvResult2.text = ""
    clear = ByteArray(0)
    try {
      val entry = KeyStore.getInstance(Constants.ANDROID_KEYSTORE).run {
        load(null)
        getEntry(Constants.keyname, null)
      }
      val prKey = (entry as KeyStore.PrivateKeyEntry).privateKey
      val cipher: Cipher = Cipher.getInstance(Constants.ENC_ALGO)
      cipher.init(Cipher.ENCRYPT_MODE, prKey)
      result = cipher.doFinal(content)
      // display encrypted result
      tvResult.text = String.format(InStrings.encFormat , result.size, byteArrayToHex(result))
    }
    catch (e: Exception) {
      tvExc.text = e.message
    }
  }

  fun decryptResult() {
    if (content.size == 0 || result.size == 0) return
    try {
      val entry = KeyStore.getInstance(Constants.ANDROID_KEYSTORE).run {
        load(null)
        getEntry(Constants.keyname, null)
      }
      val puKey = (entry as KeyStore.PrivateKeyEntry).certificate.publicKey
      val cipher: Cipher = Cipher.getInstance(Constants.ENC_ALGO)
      cipher.init(Cipher.DECRYPT_MODE, puKey)
      clear = cipher.doFinal(result)
      // display decrypted clear content
      tvResult2.text = String.format(InStrings.decFormat , clear.size, byteArrayToHex(clear))
    }
    catch (e: Exception) {
      tvExc.text = e.message
    }
  }

  /*
   *      Menu - sign and verify
   */

  fun signContent() {
    if (content.size == 0) return
    clear = ByteArray(0)
    tvResult2.text = ""
    try {
      val entry = KeyStore.getInstance(Constants.ANDROID_KEYSTORE).run {
        load(null)
        getEntry(Constants.keyname, null)
      }
      val prKey = (entry as KeyStore.PrivateKeyEntry).privateKey
      val sg = Signature.getInstance(Constants.SIGN_ALGO)
      sg.initSign(prKey)
      sg.update(content)
      result = sg.sign()
      // display signature
      tvResult.text = String.format(InStrings.signFormat , result.size, byteArrayToHex(result))
    }
    catch  (e: Exception) {
      tvExc.text = e.message
    }
  }

  fun verifySignature() {
    if (content.size == 0 || result.size == 0) return
    try {
      val entry = KeyStore.getInstance(Constants.ANDROID_KEYSTORE).run {
        load(null)
        getEntry(Constants.keyname, null)
      }
      val puKey = (entry as KeyStore.PrivateKeyEntry).certificate.publicKey
      val sg = Signature.getInstance(Constants.SIGN_ALGO)
      sg.initVerify(puKey)
      sg.update(content)
      val verified = sg.verify(result)
      tvResult2.text = if (verified) "verified" else "INVALID!"
    }
    catch (e: Exception) {
      tvExc.text = e.message
    }
  }

  /*
   *     Menu - show public key certificate in three formats
   */

  fun showCertificate() {
    clearScreen()
    try {
      val entry = KeyStore.getInstance(Constants.ANDROID_KEYSTORE).run {
        load(null)
        getEntry(Constants.keyname, null)
      }
        val cert = (entry as KeyStore.PrivateKeyEntry).certificate
        val encCert = cert.encoded
        val strCert = cert.toString()
        val b64Cert = InStrings.beginCert + Base64.encodeToString(encCert, Base64.DEFAULT) + InStrings.endCert
        val text = String.format(InStrings.certFormat, encCert.size, byteArrayToHex(encCert),
                                 b64Cert.length, b64Cert, strCert)
        tvMsg.text = text
    }
    catch (e: Exception) {
      tvExc.text = e.message
    }
  }

  /*
   *     Menu - clear displayed text
   */

  fun clearScreen() {
    tvExc.text = ""
    tvMsg.text = ""
    tvResult.text = ""
    tvResult2.text = ""
    content = ByteArray(0)
    result = ByteArray(0)
    clear = ByteArray(0)
  }
}